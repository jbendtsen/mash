// assets.h is auto-generated by prepare-shaders.py
#include "assets.h"

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mash.h"

#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>

#define DEFAULT_FONT_PATH "content/Monaco_Regular.ttf"

static Font_Handle font_face = nullptr;
static Font_Render font_render = {0};

static Grid grid = {0};
static File file = {0};
static Formatter formatter = {0};

static bool needs_resubmit = true;

const char **get_required_instance_extensions(uint32_t *n_inst_exts) {
	return glfwGetRequiredInstanceExtensions(n_inst_exts);
}

VkResult create_window_surface(VkInstance& instance, void *window, VkSurfaceKHR *surface) {
	return glfwCreateWindowSurface(instance, (GLFWwindow*)window, nullptr, surface);
}

int upload_glyphsets(Vulkan& vk, Font_Handle fh, Font_Render *renders, int n_renders) {
	if (!vk.glyphset_pool.size) {
		vk.glyphset_pool = vk.allocate_gpu_memory(GLYPHSET_POOL_SIZE);
		if (!vk.glyphset_pool.size)
			return __LINE__;
	}

	renders[0].buf = vk.glyphset_pool.staging_area;
	make_font_render(fh, renders[0]);

	return vk.push_to_gpu(vk.glyphset_pool, 0, renders[0].total_size);
}

int render_and_upload_views(Vulkan& vk, View *views, int n_views, Font_Render *renders) {
	if (!vk.grids_pool.size) {
		vk.grids_pool = vk.allocate_gpu_memory(GRIDS_POOL_SIZE);
		if (!vk.grids_pool.size)
			return __LINE__;
	}

	Cell *cells = (Cell*)vk.grids_pool.staging_area;
	View& v = views[0];
	v.grid->render_into(v.text, cells, v.formatter);

	int res = vk.push_to_gpu(vk.grids_pool, 0, v.grid->rows * v.grid->cols * sizeof(Cell));
	if (res != 0)
		return __LINE__;

	if (!vk.view_params || n_views > vk.view_param_cap) {
		int cap = VIEW_PARAMS_INITIAL_CAP;
		while (cap < n_views)
			cap *= 2;

		auto vps = new View_Params[cap];
		if (vk.view_params)
			delete[] vk.view_params;

		vk.view_params = vps;
		vk.view_param_cap = cap;
	}
	vk.n_view_params = n_views;

	for (int i = 0; i < vk.n_view_params; i++) {
		Font_Render *r = &renders[views[i].font_render_idx];

		vk.view_params[i] = {
			.view_origin = {0, 0},
			.view_size = {(uint32_t)vk.wnd_width, (uint32_t)vk.wnd_height},
			.cell_size = {(uint32_t)r->glyph_w, (uint32_t)r->glyph_h},
			.columns = (uint32_t)v.grid->cols,
			.grid_cell_offset = 0,
			.glyphset_byte_offset = 0,
			.glyph_overlap_w = (uint32_t)r->overlap_w
		};
	}

	return 0;
}

int start_app(Vulkan& vk, GLFWwindow *window) {
	auto resize_grid = [&vk](Grid& g) {
		g.rows = (vk.wnd_height + font_render.glyph_h - 1) / font_render.glyph_h;
		g.cols = (vk.wnd_width + font_render.glyph_w - 1) / font_render.glyph_w;
	};
	resize_grid(grid);

	View view = {
		.grid = &grid,
		.text = &text,
		.formatter = &formatter,
		.font_render_idx = 0
	};

	int res = upload_glyphsets(vk, font_face, &font_render, 1);
	if (res != 0) return res;

	res = render_and_upload_views(vk, &view, 1, &font_render);
	if (res != 0) return res;

	res = vk.create_descriptor_set();
	if (res != 0) return res;

	res = vk.construct_pipeline();
	if (res != 0) return res;

	needs_resubmit = true;

	while (!glfwWindowShouldClose(window)) {
		glfwWaitEventsTimeout(0.5);

		int w, h;
		glfwGetFramebufferSize(window, &w, &h);
		if (w != vk.wnd_width || h != vk.wnd_height) {
			vk.recreate_swapchain(w, h);
			needs_resubmit = true;
		}

		if (needs_resubmit) {
			resize_grid(grid);

			res = render_and_upload_views(vk, &view, 1, &font_render);
			if (res != 0) return res;

			res = vk.update_command_buffers();
			if (res != 0) return res;

			needs_resubmit = false;
		}

		res = vk.render();
	}

	return res;
}

// This function **doesn't** get called from a different thread, so we can let it access globals
void key_callback(GLFWwindow *window, int key, int scancode, int action, int mods) {
	int64_t move_down = 0;
	int64_t move_right = 0;

	if (action == GLFW_PRESS || action == GLFW_REPEAT) {
		if (key == GLFW_KEY_UP)
			move_down--;
		else if (key == GLFW_KEY_DOWN)
			move_down++;
		else if (key == GLFW_KEY_LEFT)
			move_right--;
		else if (key == GLFW_KEY_RIGHT)
			move_right++;
	}

	int64_t temp = grid.row_offset + move_down;
	grid.row_offset = temp >= 0 ? temp : 0;

	temp = grid.col_offset + move_right;
	grid.col_offset = temp >= 0 ? temp : 0;

	needs_resubmit = true;
}

int main(int argc, char **argv) {
	atexit([](){ft_quit();});

	font_face = load_font_face(DEFAULT_FONT_PATH);
	if (!font_face)
		return 1;

	// TODO: Use system DPI
	font_render = size_up_font_render(font_face, 10, 96, 96);

	formatter.colors[0] = 0x080808ff;
	formatter.colors[1] = 0xf0f0f0ff;
	formatter.spaces_per_tab = 4;

	VkShaderModuleCreateInfo vertex_buf = {
		.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
		.pCode = (uint32_t*)vertex_shader_data,
		.codeSize = sizeof(vertex_shader_data)
	};
	VkShaderModuleCreateInfo fragment_buf = {
		.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
		.pCode = (uint32_t*)fragment_shader_data,
		.codeSize = sizeof(fragment_shader_data)
	};

	if (file.open("vulkan.cpp") < 0)
		return 2;

	text.enumerate_newlines();

	glfwInit();
	glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
	glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

	GLFWmonitor *monitor = glfwGetPrimaryMonitor();
	const GLFWvidmode *vid_mode = glfwGetVideoMode(monitor);
	//int width = vid_mode->width, height = vid_mode->height;
	int width = 800, height = 600;

	glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);

	GLFWwindow *window = glfwCreateWindow(width, height, "Mash", nullptr, nullptr);
	if (!window) {
		fprintf(stderr, "Failed to create GLFW window\n");
		glfwTerminate();
		return 3;
	}

	glfwSetKeyCallback(window, key_callback);

	Vulkan vk;
	vk.glfw_monitor = (void*)monitor;
	vk.glfw_window = (void*)window;

	int res = init_vulkan(vk, vertex_buf, fragment_buf, width, height);
	if (res == 0)
		res = start_app(vk, window);

	file.close();

	vk.close();
	glfwDestroyWindow(window);
	glfwTerminate();
	return res;
}
